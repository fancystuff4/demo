function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import yargs from 'yargs';
var TEST_MODES = {
  modes: {
    describe: 'The types/modes of tests to run',
    alias: 'm',
    array: true,
    default: ['lint', 'type', 'spec']
  }
};
var TEST_PATTERN = {
  pattern: {
    describe: 'Regexp pattern string that is matched against all tests paths before executing the test',
    alias: 'p',
    string: true,
    default: ''
  }
};
var BUILD_FORMATS = {
  formats: {
    describe: 'The module formats to build',
    alias: 'f',
    array: true,
    default: ['type', 'esm', 'cjs']
  }
};
var OUTPUT_PATH = {
  out: {
    describe: 'Path to the output directory for the built formats',
    alias: 'o',
    default: '',
    string: true
  }
};
export var CREATE_ARGS = _objectSpread({}, BUILD_FORMATS, {}, OUTPUT_PATH, {}, TEST_MODES);
export var CREATE_POS_ARGS = {
  name: {
    description: 'Name of the library to create',
    default: '',
    string: true
  }
};
export var TEST_ARGS = _objectSpread({}, TEST_MODES, {}, TEST_PATTERN, {
  watch: {
    describe: 'Re-run tests when source files change',
    alias: 'w',
    type: 'boolean',
    default: false
  }
});
export var START_ARGS = _objectSpread({}, TEST_MODES, {}, TEST_PATTERN);
export var BUILD_ARGS = _objectSpread({}, BUILD_FORMATS, {}, OUTPUT_PATH, {
  watch: {
    describe: 'Update built assets when source files change',
    alias: 'w',
    type: 'boolean',
    default: false
  }
});
export var INTEGRATE_ARGS = _objectSpread({}, TEST_MODES, {}, TEST_PATTERN);
export var CREATE_COMMAND = 'create';
export var TEST_COMMAND = 'test';
export var START_COMMAND = 'start';
export var BUILD_COMMAND = 'build';
export var INTEGRATE_COMMAND = 'integrate';
export var DEFAULT_COMMAND = CREATE_COMMAND;
export var parseArgs = function parseArgs(args) {
  return yargs(args).version().command(TEST_COMMAND, 'Runs linting, typing & Jest tests for the library', TEST_ARGS).command(START_COMMAND, "Runs the lib's tests in watch mode", START_ARGS).command(BUILD_COMMAND, 'Builds the library into desired module formats', BUILD_ARGS).command(INTEGRATE_COMMAND, 'Runs integration tests for the library', INTEGRATE_ARGS).command(["".concat(CREATE_COMMAND, " [name]"), '$0'], 'Creates a new library with test/build infra using @benmvp/cli', function (commandYargs) {
    return commandYargs.options(CREATE_ARGS).positional('name', CREATE_POS_ARGS.name);
  }).completion().epilog('For more details, visit https://github.com/benmvp/benmvp-cli/blob/master/API.md').help().argv;
};