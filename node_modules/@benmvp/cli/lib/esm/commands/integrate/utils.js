function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

import { VALID_TEST_MODES } from '../test/utils';
var VALID_TEST_MODE_NAMES = new Set(Object.keys(VALID_TEST_MODES));
/**
 * Retrieves the command-line arguments to pass to `benmvp test` based on the specified parameters
 * @param {IntegrateParams} params
 * @param {TestMode[]} options.modes List of the types or modes of tests to run
 * @param {string} options.pattern  Regexp pattern string that is matched against all tests paths
 *  before executing the test
 * @returns {string[]}
 */

export var getTestArgs = function getTestArgs(_ref) {
  var modes = _ref.modes,
      pattern = _ref.pattern;
  var validSelectedModes = modes.filter(function (mode) {
    return VALID_TEST_MODE_NAMES.has(mode);
  });

  if (!validSelectedModes.length || validSelectedModes.length < modes.length) {
    throw new Error("Invalid test modes specified: ".concat(modes));
  }

  var testArgs = ['--modes'].concat(_toConsumableArray(validSelectedModes));

  if (pattern) {
    testArgs.push('--pattern', pattern);
  }

  return testArgs;
};