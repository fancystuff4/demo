"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUpdatePackageInfo = void 0;

var _path = require("path");

var _args = require("../../cli/args");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var getOutputPath = function getOutputPath(out) {
  return out || 'lib';
};

var areIdentical = function areIdentical(first, second) {
  var firstLookup = new Set(first);
  return first.length === second.length && second.every(function (item) {
    return firstLookup.has(item);
  });
};

var formatBuildScript = function formatBuildScript(formats, out) {
  var args = [];

  if (!areIdentical(formats, _args.CREATE_ARGS.formats.default)) {
    args.push('--formats', formats.join(' '));
  }

  if (out !== _args.CREATE_ARGS.out.default) {
    args.push('--out', getOutputPath(out));
  }

  return "benmvp build ".concat(args.join(' ')).trim();
};

var formatTestScript = function formatTestScript(command, modes) {
  var args = [];

  if (!areIdentical(modes, _args.CREATE_ARGS.modes.default)) {
    args.push('--modes', modes.join(' '));
  }

  return "benmvp ".concat(command, " ").concat(args.join(' ')).trim();
};

/**
 * Updates package.json contents with various properties needed when creating a benmvp lib
 * @param {PackageJson} initialPackageInfo Initial package.json contents
 * @param {CreateOptions} options
 * @param {string} options.libraryName The name of the library being created
 * @param {ModuleFormat[]} options.formats A list of the module formats when building
 * @param {string} options.out A path (relative or absolute) to the output directory
 *  for the built module formats
 * @param {TestMode[]} options.modes List of the types or modes of tests to run when testing
 * @returns {PackageJson} Modified package.json reading for saving
 */
var getUpdatePackageInfo = function getUpdatePackageInfo(initialPackageInfo, _ref) {
  var libraryName = _ref.libraryName,
      formats = _ref.formats,
      out = _ref.out,
      modes = _ref.modes;
  var outputPath = getOutputPath(out);
  var formatsLookup = new Set(formats);

  var packageInfo = _objectSpread({}, initialPackageInfo); // Overwrite "name" to libraryName if it exists
  // especially if it is a scoped package and the name doesn't
  // match the directory name when the package.json was initialized


  if (libraryName) {
    packageInfo.name = libraryName;
  } // enforce no version in package.json stored in git.
  // when semantic-release releases the package it'll
  // add the correct version, so we don't have to manually
  // manage it


  packageInfo.version = '0.0.0-semantically-released'; // Overwrite "main" to `out` + `cjs/index.js`, if `cjs` format is specified

  if (formatsLookup.has('cjs')) {
    packageInfo.main = (0, _path.join)(outputPath, 'cjs/index.js');
  } // Overwrite "module" & "jsnext:main" to `out` + `esm/index.js`, if `esm` format is specified


  if (formatsLookup.has('esm')) {
    packageInfo.module = (0, _path.join)(outputPath, 'esm/index.js');
    packageInfo['jsnext:main'] = (0, _path.join)(outputPath, 'esm/index.js');
  } // Overwrite "types" to `out` + `types/index.d.ts`, if `type` format is specified


  if (formatsLookup.has('type')) {
    packageInfo.types = (0, _path.join)(outputPath, 'types/index.d.ts');
  } // Overwrite "files" to `out` array (formatted to begin w/ folder name)


  packageInfo.files = [(0, _path.resolve)(outputPath).replace("".concat(process.cwd(), "/"), '')]; // Overwrite license to MIT

  packageInfo.license = 'MIT'; // Overwrite "publishConfig.access" to ensure that scoped packages
  // can also be published since by default they are restricted
  // (https://docs.npmjs.com/misc/config#access)

  packageInfo.publishConfig = _objectSpread({}, packageInfo.publishConfig, {
    access: 'public'
  }); // - Overwrite "engines.node"

  packageInfo.engines = _objectSpread({}, packageInfo.engines, {
    node: '>= 8'
  });
  packageInfo.scripts = _objectSpread({}, packageInfo.scripts, {
    // Overwrite "scripts.start" to "benmvp start" + `modes` (omitting defaults)
    start: formatTestScript('start', modes),
    // Overwrite "scripts.test" to "benmvp test" + `modes` (omitting defaults)
    test: formatTestScript('test', modes),
    // Overwrite "scripts.build" to `benmvp build` w/ `formats` + `out` (omitting defaults)
    build: formatBuildScript(formats, out),
    // Overwrite "scripts.integrate" to "benmvp integrate" + `modes` (omitting defaults)
    integrate: formatTestScript('integrate', modes)
  });
  return packageInfo;
};

exports.getUpdatePackageInfo = getUpdatePackageInfo;