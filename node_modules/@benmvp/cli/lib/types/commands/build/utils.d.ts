import { ModuleFormat } from '../types';
interface BabelOptions {
    presets: string[];
    plugins?: string[];
    rootMode?: 'root' | 'upward' | 'upward-optional';
    configFile?: string;
    envName?: string;
    sourceType?: 'script' | 'module';
    ignore?: string[];
    only?: string[];
    retainLines?: boolean;
    compact?: true | false | 'auto';
    minified?: boolean;
    auxiliaryCommentBefore?: string;
    auxiliaryCommentAfter?: string;
    sourceMaps?: boolean;
    sourceFileName?: string;
    sourceRoot?: string;
    moduleRoot?: string;
    moduleIds?: string[];
    moduleId?: string;
    babelrc?: boolean;
    highlightCode?: boolean;
    comments?: boolean;
}
interface CLIOptions {
    filename?: string;
    filenames: string[];
    extensions?: string;
    keepFileExtension?: boolean;
    watch?: boolean;
    skipInitialBuild?: boolean;
    outFile?: string;
    outDir?: string;
    relative?: boolean;
    copyFiles?: boolean;
    includeDotfiles?: boolean;
    verbose?: boolean;
    deleteDirOnStart?: boolean;
    sourceMapTarget?: string;
}
interface BabelCLIOptions {
    babelOptions: BabelOptions;
    cliOptions: CLIOptions;
}
export interface BuildArgs {
    formats: Set<ModuleFormat>;
    out: string;
    watch: boolean;
}
/**
 * Gets an array of CLI options/arguments to pass babel, one for each valid format
 * @param {BuildArgs} options
 * @param {Set<ModuleFormat>} options.formats A set of the module formats to build
 * @param {string} options.out A path (relative or absolute) to the output directory
 *  for the built module formats
 * @param {boolean} options.watch A flag indicating whether or not to continuously
 *  generate the built module formats whenever source files change
 * @returns {BabelCLIOptions[]}
 */
export declare const getBabelCLIOptionsList: ({ formats, out: outputPath, watch, }: BuildArgs) => BabelCLIOptions[];
/**
 * Gets a list of arguments to pass Typescript
 * @param {BuildArgs} options
 * @param {Set<ModuleFormat>} options.formats A set of the module formats to build
 * @param {string} options.out A path (relative or absolute) to the output directory
 *  for the type definitions
 * @param {boolean} options.watch A flag indicating whether or not to continuously
 *  generate the type definitions whenever source files change
 * @returns {string[] | null}
 */
export declare const getTypescriptArgs: ({ formats, out, watch, }: BuildArgs) => string[] | null;
/**
 * Gets list of glob patterns of copied files that should be deleted after building
 * @param {string} outputPath A path (relative or absolute) to the output directory
 *  for the type definitions
 * @returns {string[]}
 */
export declare const getCopiedFilesToDelete: (outputPath: string) => string[];
export {};
